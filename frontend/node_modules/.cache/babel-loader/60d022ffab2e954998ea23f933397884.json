{"ast":null,"code":"var _jsxFileName = \"/Users/jielianglin/Desktop/projects/m-v2-prod/frontend/src/components/upload/annotation/P5Mold.js\",\n    _s = $RefreshSig$();\n\nimport React from 'react';\nimport Sketch from 'react-p5';\nimport ColorSelector from './ColorSelector';\nimport FileInput from '../FileInput';\nimport EraserIcon from './eraser/EraserIcon.png';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar TWO_PI;\nvar HALF_PI;\nvar b;\nvar img;\nvar pg;\nvar imgWidth;\nvar imgHeight;\nvar angleSlider;\nlet distanceSlider;\nvar blobPoints = [];\nlet numPoints = 6; // try different values for different shaped blobs\n\nlet baseRadius = 100;\nlet radiusRandomness = 0.2; // amount of random variation in the blob radius \n\nlet cpOffsetAngle;\nlet cpdist;\nexport default function P5Mold() {\n  _s();\n\n  const [color, setColor] = React.useState(['#ff0000']);\n  const [image, setImage] = React.useState(null);\n\n  const setup = (p5, canvasParentRef) => {\n    p5.createCanvas(400, 400).parent(canvasParentRef);\n    pg = p5.createGraphics(600, 600);\n    img = p5.loadImage(image, img => {\n      p5.image(img, 0, 0);\n    });\n    angleSlider = p5.createSlider(0, 2.4, 2, 0.05);\n    angleSlider.position(200, 250);\n    angleSlider.changed(buildBlob);\n    distanceSlider = p5.createSlider(10, 150, 50, 5);\n    distanceSlider.position(200, 300);\n    distanceSlider.changed(buildBlob);\n    buildBlob();\n  };\n\n  const draw = p5 => {\n    imgWidth = img.width;\n    imgHeight = img.height;\n\n    if (imgWidth > 0 && imgHeight > 0) {\n      p5.resizeCanvas(imgWidth, imgHeight);\n    }\n\n    p5.image(img, 0, 0);\n    pg.fill(color);\n    pg.stroke(color);\n    pg.beginShape();\n    pg.vertex();\n\n    for (b = 1; b < blobPoints.length; b++) {\n      // start from 1 (the second node in the ring)\n      let bp = blobPoints[b];\n      let pp = blobPoints[b - 1]; // previous node\n      // bezier points go:\n      // second control point from previous node\n      // first control point from this node\n      // x and y of this node\n\n      pg.bezierVertex(pp.cp[1].x, pp.cp[1].y, bp.cp[0].x, bp.cp[0].y, bp.x, bp.y);\n      let lastp = blobPoints[blobPoints.length - 1];\n      let firstp = blobPoints[0];\n      pg.bezierVertex(lastp.cp[1].x, lastp.cp[1].y, firstp.cp[0].x, firstp.cp[0].y, firstp.x, firstp.y);\n      pg.endShape();\n    }\n\n    p5.image(pg, 0, 0, imgWidth, imgHeight);\n  };\n\n  function buildBlob(p5) {\n    // this creates a new blob with current settings\n    blobPoints = []; // empty the array\n    // get values from the sliders\n\n    cpOffsetAngle = angleSlider.value();\n    cpdist = distanceSlider.value(); // generate points around a ring\n\n    for (let p = 0; p < numPoints; p++) {\n      let a = p * Math.PI * 2 / numPoints; // angle of this point\n\n      let r = baseRadius + Math.random(-radiusRandomness * baseRadius, radiusRandomness * baseRadius); // radius randomiser\n      // create an object storing the x and y coordinate, and the angle\n      // as well as an empty array for storing the control points\n\n      let bp = {\n        x: Math.cos(a) * r,\n        y: Math.sin(a) * r,\n        angle: a,\n        cp: []\n      };\n      blobPoints.push(bp);\n    }\n\n    for (let b = 0; b < blobPoints.length; b++) {\n      // run through the ring\n      let thisp = blobPoints[b]; // current node\n\n      let randomangle = Math.random(-cpOffsetAngle, cpOffsetAngle); // random angle for control points\n\n      let cp1angle = thisp.angle - (Math.PI / 2 + randomangle);\n      let cp2angle = thisp.angle + (Math.PI / 2 - randomangle); // make sure the two angles of the control points add up to 180 degrees\n      // to keep them in the same line and create a smooth join\n      // create the control points\n      // note that we use cos and sin to create coordinates\n      // relative to the node point\n\n      let cp1 = {\n        x: thisp.x + Math.cos(cp1angle) * cpdist,\n        y: thisp.y + Math.sin(cp1angle) * cpdist\n      };\n      let cp2 = {\n        x: thisp.x + Math.cos(cp2angle) * cpdist,\n        y: thisp.y + Math.sin(cp2angle) * cpdist\n      };\n      thisp.cp = [cp1, cp2]; // store control points in the current node in the blobPoints array\n    }\n  }\n\n  if (image) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [image && /*#__PURE__*/_jsxDEV(\"div\", {\n        children: /*#__PURE__*/_jsxDEV(Sketch, {\n          setup: setup,\n          draw: draw\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 138,\n          columnNumber: 25\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 137,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(ColorSelector, {\n        selectColor: color => setColor(color)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 141,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 13\n    }, this);\n  } else {\n    return /*#__PURE__*/_jsxDEV(FileInput, {\n      selectImage: setImage\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 147,\n      columnNumber: 13\n    }, this);\n  }\n}\n\n_s(P5Mold, \"lo/BMPVj4XUHEYds8caQUIfo3HA=\");\n\n_c = P5Mold;\n\nvar _c;\n\n$RefreshReg$(_c, \"P5Mold\");","map":{"version":3,"sources":["/Users/jielianglin/Desktop/projects/m-v2-prod/frontend/src/components/upload/annotation/P5Mold.js"],"names":["React","Sketch","ColorSelector","FileInput","EraserIcon","TWO_PI","HALF_PI","b","img","pg","imgWidth","imgHeight","angleSlider","distanceSlider","blobPoints","numPoints","baseRadius","radiusRandomness","cpOffsetAngle","cpdist","P5Mold","color","setColor","useState","image","setImage","setup","p5","canvasParentRef","createCanvas","parent","createGraphics","loadImage","createSlider","position","changed","buildBlob","draw","width","height","resizeCanvas","fill","stroke","beginShape","vertex","length","bp","pp","bezierVertex","cp","x","y","lastp","firstp","endShape","value","p","a","Math","PI","r","random","cos","sin","angle","push","thisp","randomangle","cp1angle","cp2angle","cp1","cp2"],"mappings":"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","sourcesContent":["import React from 'react';\nimport Sketch from 'react-p5';\nimport ColorSelector from './ColorSelector';\nimport FileInput from '../FileInput';\nimport EraserIcon from './eraser/EraserIcon.png'\n\nvar TWO_PI;\nvar HALF_PI;\nvar b;\nvar img;\nvar pg;\nvar imgWidth;\nvar imgHeight;\n\nvar angleSlider;\nlet distanceSlider;\n\nvar blobPoints = [];\nlet numPoints = 6; // try different values for different shaped blobs\nlet baseRadius = 100;\nlet radiusRandomness = 0.2; // amount of random variation in the blob radius \nlet cpOffsetAngle;\nlet cpdist;\n\nexport default function P5Mold() {\n    const [color, setColor] = React.useState(['#ff0000']);\n    const [image, setImage] = React.useState(null);\n\n\n    const setup = (p5, canvasParentRef) => {\n        p5.createCanvas(400, 400).parent(canvasParentRef);\n        pg = p5.createGraphics(600, 600);\n        img = p5.loadImage(image, img => {\n            p5.image(img, 0, 0);\n        });\n\n        angleSlider = p5.createSlider(0, 2.4, 2, 0.05);\n        angleSlider.position(200, 250);\n        angleSlider.changed(buildBlob);\n\n        distanceSlider = p5.createSlider(10, 150, 50, 5);\n        distanceSlider.position(200, 300);\n        distanceSlider.changed(buildBlob);\n\n        buildBlob();\n    }\n\n    const draw = p5 => {\n\n        imgWidth = img.width;\n        imgHeight = img.height;\n\n        if (imgWidth > 0 && imgHeight > 0) {\n            p5.resizeCanvas(imgWidth, imgHeight);\n        }\n\n        p5.image(img, 0, 0);\n\n        pg.fill(color);\n        pg.stroke(color);\n        pg.beginShape();\n        pg.vertex();\n        for (b = 1; b < blobPoints.length; b++) {\n            // start from 1 (the second node in the ring)\n            let bp = blobPoints[b];\n            let pp = blobPoints[b - 1]; // previous node\n            // bezier points go:\n            // second control point from previous node\n            // first control point from this node\n            // x and y of this node\n            pg.bezierVertex(pp.cp[1].x, pp.cp[1].y, bp.cp[0].x, bp.cp[0].y, bp.x, bp.y);\n\n            let lastp = blobPoints[blobPoints.length - 1];\n            let firstp = blobPoints[0]\n\n            pg.bezierVertex(lastp.cp[1].x, lastp.cp[1].y, firstp.cp[0].x, firstp.cp[0].y, firstp.x, firstp.y);\n            pg.endShape();\n\n        }\n        p5.image(pg, 0, 0, imgWidth, imgHeight);\n    }\n\n    function buildBlob(p5) { // this creates a new blob with current settings\n        blobPoints = []; // empty the array\n\n        // get values from the sliders\n        cpOffsetAngle = angleSlider.value();\n        cpdist = distanceSlider.value();\n\n        // generate points around a ring\n        for (let p = 0; p < numPoints; p++) {\n            let a = p * Math.PI * 2 / numPoints; // angle of this point\n            let r = baseRadius + Math.random(-radiusRandomness * baseRadius, radiusRandomness * baseRadius); // radius randomiser\n            // create an object storing the x and y coordinate, and the angle\n            // as well as an empty array for storing the control points\n            let bp = {\n                x: Math.cos(a) * r,\n                y: Math.sin(a) * r,\n                angle: a,\n                cp: []\n            };\n            blobPoints.push(bp);\n        }\n\n        for (let b = 0; b < blobPoints.length; b++) { // run through the ring\n            let thisp = blobPoints[b]; // current node\n            let randomangle = Math.random(-cpOffsetAngle, cpOffsetAngle); // random angle for control points\n\n            let cp1angle = thisp.angle - (Math.PI / 2 + randomangle);\n            let cp2angle = thisp.angle + (Math.PI / 2 - randomangle);\n            // make sure the two angles of the control points add up to 180 degrees\n            // to keep them in the same line and create a smooth join\n\n            // create the control points\n            // note that we use cos and sin to create coordinates\n            // relative to the node point\n            let cp1 = {\n                x: thisp.x + (Math.cos(cp1angle) * cpdist),\n                y: thisp.y + (Math.sin(cp1angle) * cpdist)\n            };\n            let cp2 = {\n                x: thisp.x + (Math.cos(cp2angle) * cpdist),\n                y: thisp.y + (Math.sin(cp2angle) * cpdist)\n            };\n\n            thisp.cp = [cp1, cp2]; // store control points in the current node in the blobPoints array\n\n        }\n    }\n\n\n    if (image) {\n\n        return (\n            <div>\n                {image && (\n                    <div>\n                        <Sketch setup={setup} draw={draw} />\n                    </div>\n                )}\n                <ColorSelector selectColor={color => setColor(color)} />\n            </div>\n        )\n\n    } else {\n        return (\n            <FileInput selectImage={setImage} />\n        );\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}