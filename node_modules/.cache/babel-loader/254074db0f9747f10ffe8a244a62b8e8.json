{"ast":null,"code":"let updateQueue = makeQueue();\n\nconst raf = fn => schedule(fn, updateQueue);\n\nlet writeQueue = makeQueue();\n\nraf.write = fn => schedule(fn, writeQueue);\n\nlet onStartQueue = makeQueue();\n\nraf.onStart = fn => schedule(fn, onStartQueue);\n\nlet onFrameQueue = makeQueue();\n\nraf.onFrame = fn => schedule(fn, onFrameQueue);\n\nlet onFinishQueue = makeQueue();\n\nraf.onFinish = fn => schedule(fn, onFinishQueue);\n\nlet timeouts = [];\n\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n\n  let cancel = () => {\n    let i = timeouts.findIndex(t => t.cancel == cancel);\n    if (~i) timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n\n  let timeout = {\n    time,\n    handler,\n    cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\n\nlet findTimeout = time => ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length);\n\nraf.cancel = fn => {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\n\nraf.sync = fn => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\n\nraf.throttle = fn => {\n  let lastArgs;\n\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n\n  function throttled(...args) {\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n\n  throttled.handler = fn;\n\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n\n  return throttled;\n};\n\nlet nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame : () => {};\n\nraf.use = impl => nativeRaf = impl;\n\nraf.now = typeof performance != \"undefined\" ? () => performance.now() : Date.now;\n\nraf.batchedUpdates = fn => fn();\n\nraf.catch = console.error;\nlet ts = -1;\nlet sync = false;\n\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    nativeRaf(loop);\n  }\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\n\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler());\n    __raf.count -= count;\n  }\n\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\n\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, fn => fn(arg) && next.add(fn));\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n\n  };\n}\n\nfunction eachSafely(values, each) {\n  values.forEach(value => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\n\nconst __raf = {\n  count: 0,\n\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n\n};\nexport { __raf, raf };","map":{"version":3,"sources":["../src/raf.ts"],"names":[],"mappings":"AAWA,IAAI,WAAA,GAAc,SAAA,EAAlB;;YAMyB,EAAA,IAAM,QAAA,CAAS,EAAT,EAAa,WAAb,C;;AAE/B,IAAA,UAAA,GAAiB,SAAA,EAAjB;;AACA,GAAA,CAAI,KAAJ,GAAY,EAAA,IAAM,QAAA,CAAS,EAAT,EAAa,UAAb,CAAlB;;AAEA,IAAA,YAAA,GAAmB,SAAA,EAAnB;;AACA,GAAA,CAAI,OAAJ,GAAc,EAAA,IAAM,QAAA,CAAS,EAAT,EAAa,YAAb,CAApB;;AAEA,IAAA,YAAA,GAAmB,SAAA,EAAnB;;AACA,GAAA,CAAI,OAAJ,GAAc,EAAA,IAAM,QAAA,CAAS,EAAT,EAAa,YAAb,CAApB;;AAEA,IAAA,aAAA,GAAoB,SAAA,EAApB;;AACA,GAAA,CAAI,QAAJ,GAAe,EAAA,IAAM,QAAA,CAAS,EAAT,EAAa,aAAb,CAArB;;AAEA,IAAA,QAAA,GAA0B,EAA1B;;AACA,GAAA,CAAI,UAAJ,GAAiB,CAAA,OAAA,EAAA,EAAA,KAAA;AACf,MAAA,IAAA,GAAW,GAAA,CAAI,GAAJ,KAAY,EAAvB;;AACA,MAAA,MAAA,GAAa,MAAA;AACX,QAAA,CAAA,GAAQ,QAAA,CAAS,SAAT,CAAmB,CAAA,IAAK,CAAA,CAAE,MAAF,IAAY,MAApC,CAAR;AACA,QAAI,CAAC,CAAL,EAAQ,QAAA,CAAS,MAAT,CAAgB,CAAhB,EAAmB,CAAnB;AACR,IAAA,KAAA,CAAM,KAAN,IAAe,CAAC,CAAD,GAAK,CAAL,GAAS,CAAxB;AAAwB,GAH1B;;AAMA,MAAA,OAAA,GAAuB;AAAE,IAAA,IAAF;AAAQ,IAAA,OAAR;AAAiB,IAAA;AAAjB,GAAvB;AACA,EAAA,QAAA,CAAS,MAAT,CAAgB,WAAA,CAAY,IAAZ,CAAhB,EAAmC,CAAnC,EAAsC,OAAtC;AACA,EAAA,KAAA,CAAM,KAAN,IAAe,CAAf;AAEA,EAAA,KAAA;AACA,SAAO,OAAP;AAAO,CAbT;;AAiBA,IAAA,WAAA,GAAkB,IAAA,IAChB,EAAA,CAAG,QAAA,CAAS,SAAT,CAAmB,CAAA,IAAK,CAAA,CAAE,IAAF,GAAS,IAAjC,CAAH,IAA6C,CAAC,QAAA,CAAS,MAAvD,CADF;;AAGA,GAAA,CAAI,MAAJ,GAAa,EAAA,IAAA;AACX,EAAA,WAAA,CAAY,MAAZ,CAAmB,EAAnB;AACA,EAAA,UAAA,CAAW,MAAX,CAAkB,EAAlB;AAAkB,CAFpB;;AAKA,GAAA,CAAI,IAAJ,GAAW,EAAA,IAAA;AACT,EAAA,IAAA,GAAO,IAAP;AACA,EAAA,GAAA,CAAI,cAAJ,CAAmB,EAAnB;AACA,EAAA,IAAA,GAAO,KAAP;AAAO,CAHT;;AAMA,GAAA,CAAI,QAAJ,GAAe,EAAA,IAAA;AACb,MAAA,QAAA;;AACA,WAAA,QAAA,GAAA;AACE,QAAA;AACE,MAAA,EAAA,CAAG,GAAG,QAAN,CAAA;AAAM,KADR,SACQ;AAEN,MAAA,QAAA,GAAW,IAAX;AAAW;AAAA;;AAGf,WAAA,SAAA,CAAA,GAAA,IAAA,EAAA;AACE,IAAA,QAAA,GAAW,IAAX;AACA,IAAA,GAAA,CAAI,OAAJ,CAAY,QAAZ;AAAY;;AAEd,EAAA,SAAA,CAAU,OAAV,GAAoB,EAApB;;AACA,EAAA,SAAA,CAAU,MAAV,GAAmB,MAAA;AACjB,IAAA,YAAA,CAAa,MAAb,CAAoB,QAApB;AACA,IAAA,QAAA,GAAW,IAAX;AAAW,GAFb;;AAIA,SAAO,SAAP;AAAO,CAlBT;;AAqBA,IAAA,SAAA,GACE,OAAO,MAAP,IAAiB,WAAjB,GACK,MAAA,CAAO,qBADZ,GAEI,MAAA,CAAA,CAHN;;AAKA,GAAA,CAAI,GAAJ,GAAU,IAAA,IAAS,SAAA,GAAY,IAA/B;;AACA,GAAA,CAAI,GAAJ,GAAU,OAAO,WAAP,IAAsB,WAAtB,GAAoC,MAAM,WAAA,CAAY,GAAZ,EAA1C,GAA8D,IAAA,CAAK,GAA7E;;AACA,GAAA,CAAI,cAAJ,GAAqB,EAAA,IAAM,EAAA,EAA3B;;AACA,GAAA,CAAI,KAAJ,GAAY,OAAA,CAAQ,KAApB;AAGA,IAAA,EAAA,GAAS,CAAA,CAAT;AAGA,IAAA,IAAA,GAAW,KAAX;;AAEA,SAAA,QAAA,CAAA,EAAA,EAAA,KAAA,EAAA;AACE,MAAI,IAAJ,EAAI;AACF,IAAA,KAAA,CAAM,MAAN,CAAa,EAAb;AACA,IAAA,EAAA,CAAG,CAAH,CAAA;AAAG,GAFL,MAEK;AAEH,IAAA,KAAA,CAAM,GAAN,CAAU,EAAV;AACA,IAAA,KAAA;AAAA;AAAA;;AAIJ,SAAA,KAAA,GAAA;AACE,MAAI,EAAA,GAAK,CAAT,EAAS;AACP,IAAA,EAAA,GAAK,CAAL;AACA,IAAA,SAAA,CAAU,IAAV,CAAA;AAAU;AAAA;;AAId,SAAA,IAAA,GAAA;AACE,MAAI,CAAC,EAAL,EAAK;AACH,IAAA,SAAA,CAAU,IAAV,CAAA;AACA,IAAA,GAAA,CAAI,cAAJ,CAAmB,MAAnB;AAAmB;AAAA;;AAIvB,SAAA,MAAA,GAAA;AACE,MAAA,MAAA,GAAa,EAAb;AACA,EAAA,EAAA,GAAK,GAAA,CAAI,GAAJ,EAAL;AAGA,MAAA,KAAA,GAAY,WAAA,CAAY,EAAZ,CAAZ;;AACA,MAAI,KAAJ,EAAI;AACF,IAAA,UAAA,CAAW,QAAA,CAAS,MAAT,CAAgB,CAAhB,EAAmB,KAAnB,CAAX,EAAsC,CAAA,IAAK,CAAA,CAAE,OAAF,EAA3C,CAAA;AACA,IAAA,KAAA,CAAM,KAAN,IAAe,KAAf;AAAe;;AAGjB,EAAA,YAAA,CAAa,KAAb;AACA,EAAA,WAAA,CAAY,KAAZ,CAAkB,MAAA,GAAS,IAAA,CAAK,GAAL,CAAS,EAAT,EAAa,EAAA,GAAK,MAAlB,CAAT,GAAqC,MAAvD;AACA,EAAA,YAAA,CAAa,KAAb;AACA,EAAA,UAAA,CAAW,KAAX;AACA,EAAA,aAAA,CAAc,KAAd;AAAc;;AAShB,SAAA,SAAA,GAAA;AACE,MAAA,IAAA,GAAW,IAAI,GAAJ,EAAX;AACA,MAAA,OAAA,GAAc,IAAd;AACA,SAAO;AACL,IAAA,GAAA,CAAA,EAAA,EAAA;AACE,MAAA,KAAA,CAAM,KAAN,IAAe,OAAA,IAAW,IAAX,IAAmB,CAAC,IAAA,CAAK,GAAL,CAAS,EAAT,CAApB,GAAmC,CAAnC,GAAuC,CAAtD;AACA,MAAA,IAAA,CAAK,GAAL,CAAS,EAAT;AAAS,KAHN;;AAKL,IAAA,MAAA,CAAA,EAAA,EAAA;AACE,MAAA,KAAA,CAAM,KAAN,IAAe,OAAA,IAAW,IAAX,IAAmB,IAAA,CAAK,GAAL,CAAS,EAAT,CAAnB,GAAkC,CAAlC,GAAsC,CAArD;AACA,aAAO,IAAA,CAAK,MAAL,CAAY,EAAZ,CAAP;AAAmB,KAPhB;;AASL,IAAA,KAAA,CAAA,GAAA,EAAA;AACE,UAAI,OAAA,CAAQ,IAAZ,EAAY;AACV,QAAA,IAAA,GAAO,IAAI,GAAJ,EAAP;AACA,QAAA,KAAA,CAAM,KAAN,IAAe,OAAA,CAAQ,IAAvB;AACA,QAAA,UAAA,CAAW,OAAX,EAAoB,EAAA,IAAM,EAAA,CAAG,GAAH,CAAA,IAAW,IAAA,CAAK,GAAL,CAAS,EAAT,CAArC,CAAA;AACA,QAAA,KAAA,CAAM,KAAN,IAAe,IAAA,CAAK,IAApB;AACA,QAAA,OAAA,GAAU,IAAV;AAAU;AAAA;;AAfT,GAAP;AAegB;;AAUlB,SAAA,UAAA,CAAA,MAAA,EAAA,IAAA,EAAA;AACE,EAAA,MAAA,CAAO,OAAP,CAAe,KAAA,IAAA;AACb,QAAA;AACE,MAAA,IAAA,CAAK,KAAL,CAAA;AAAK,KADP,CACO,OAAA,CAAA,EAAA;AAEL,MAAA,GAAA,CAAI,KAAJ,CAAU,CAAV;AAAU;AAAA,GAJd;AAIc;;cAMK;AAEnB,EAAA,KAAA,EAAO,CAFY;;AAInB,EAAA,KAAA,GAAA;AACE,IAAA,EAAA,GAAK,CAAA,CAAL;AACA,IAAA,QAAA,GAAW,EAAX;AACA,IAAA,YAAA,GAAe,SAAA,EAAf;AACA,IAAA,WAAA,GAAc,SAAA,EAAd;AACA,IAAA,YAAA,GAAe,SAAA,EAAf;AACA,IAAA,UAAA,GAAa,SAAA,EAAb;AACA,IAAA,aAAA,GAAgB,SAAA,EAAhB;AACA,IAAA,KAAA,CAAM,KAAN,GAAc,CAAd;AAAc;;AAZG,C","sourcesContent":["let updateQueue = makeQueue();\nconst raf = (fn) => schedule(fn, updateQueue);\nlet writeQueue = makeQueue();\nraf.write = (fn) => schedule(fn, writeQueue);\nlet onStartQueue = makeQueue();\nraf.onStart = (fn) => schedule(fn, onStartQueue);\nlet onFrameQueue = makeQueue();\nraf.onFrame = (fn) => schedule(fn, onFrameQueue);\nlet onFinishQueue = makeQueue();\nraf.onFinish = (fn) => schedule(fn, onFinishQueue);\nlet timeouts = [];\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n  let cancel = () => {\n    let i = timeouts.findIndex((t) => t.cancel == cancel);\n    if (~i)\n      timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n  let timeout = {time, handler, cancel};\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\nlet findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);\nraf.cancel = (fn) => {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\nraf.sync = (fn) => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\nraf.throttle = (fn) => {\n  let lastArgs;\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n  function throttled(...args) {\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n  throttled.handler = fn;\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n  return throttled;\n};\nlet nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame : () => {\n};\nraf.use = (impl) => nativeRaf = impl;\nraf.now = typeof performance != \"undefined\" ? () => performance.now() : Date.now;\nraf.batchedUpdates = (fn) => fn();\nraf.catch = console.error;\nlet ts = -1;\nlet sync = false;\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    nativeRaf(loop);\n  }\n}\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n  if (count) {\n    eachSafely(timeouts.splice(0, count), (t) => t.handler());\n    __raf.count -= count;\n  }\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, (fn) => fn(arg) && next.add(fn));\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n  };\n}\nfunction eachSafely(values, each) {\n  values.forEach((value) => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\nconst __raf = {\n  count: 0,\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n};\n\nexport { __raf, raf };\n//# sourceMappingURL=raf.mjs.map\n"]},"metadata":{},"sourceType":"module"}