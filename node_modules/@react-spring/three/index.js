import { invalidate, addEffect, applyProps } from '@react-three/fiber';
import { Globals as Globals$1 } from '@react-spring/core';
export * from '@react-spring/core';
import { Globals, flushCalls, createStringInterpolator, colors } from '@react-spring/shared';
import { createHost } from '@react-spring/animated';
import * as THREE from 'three';

let batchedUpdates = (callback) => callback();
let now = () => performance.now();
class FrameLoop {
  constructor(raf) {
    let idle = true;
    let writing = false;
    let lastTime = 0;
    let currentFrame = [];
    let prevFrame = [];
    let priority = 0;
    const startQueue = new Set();
    const frameQueue = new Set();
    const writeQueue = new Set();
    const start = (animation) => currentFrame.indexOf(animation) < 0 && currentFrame.splice(findIndex(currentFrame, (existing) => existing.priority > animation.priority), 0, animation);
    const loop = () => {
      if (idle)
        return;
      raf(loop);
      try {
        advance();
      } catch (e) {
        console.error(e);
      }
    };
    const kickoff = () => {
      if (idle) {
        idle = false;
        if (lastTime == 0) {
          lastTime = now();
          raf(loop);
        }
      }
    };
    const timeoutQueue = [];
    this.setTimeout = (handler, ms) => {
      const time = now() + ms;
      const cancel = () => {
        const index2 = timeoutQueue.findIndex((t) => t.cancel == cancel);
        if (index2 >= 0) {
          timeoutQueue.splice(index2, 1);
        }
      };
      const index = findIndex(timeoutQueue, (t) => t.time > time);
      const timeout = {time, handler, cancel};
      timeoutQueue.splice(index, 0, timeout);
      kickoff();
      return timeout;
    };
    const advance = this.advance = () => {
      const time = now();
      if (startQueue.size) {
        startQueue.forEach(start);
        startQueue.clear();
      }
      if (timeoutQueue.length) {
        batchedUpdates(() => {
          const count = findIndex(timeoutQueue, (t) => t.time > time);
          timeoutQueue.splice(0, count).forEach((t) => t.handler());
        });
      }
      if (time > lastTime) {
        const dt = Math.min(64, time - lastTime);
        lastTime = time;
        batchedUpdates(() => {
          if (currentFrame.length) {
            const nextFrame = prevFrame;
            for (let i = 0; i < currentFrame.length; i++) {
              const animation = currentFrame[i];
              priority = animation.priority;
              if (!animation.idle) {
                Globals.willAdvance(animation);
                animation.advance(dt);
                if (!animation.idle) {
                  nextFrame.push(animation);
                }
              }
            }
            priority = 0;
            prevFrame = currentFrame;
            prevFrame.length = 0;
            currentFrame = nextFrame;
          }
          flushCalls(frameQueue, time);
          if (writeQueue.size) {
            writing = true;
            flushCalls(writeQueue, time);
            writing = false;
          }
        });
      }
    };
    this.start = (animation) => {
      if (priority > animation.priority) {
        startQueue.add(animation);
      } else {
        start(animation);
        kickoff();
      }
    };
    this.onFrame = (cb) => {
      frameQueue.add(cb);
      kickoff();
    };
    this.onWrite = (cb) => {
      if (writing)
        cb(lastTime);
      else
        writeQueue.add(cb);
    };
    if (typeof process !== "undefined" && process.env.NODE_ENV !== "production") {
      const isIdle = () => !startQueue.size && !currentFrame.length && !timeoutQueue.length;
      const dispose = () => {
        idle = true;
        startQueue.clear();
        timeoutQueue.length = 0;
      };
      Object.defineProperties(this, {
        _idle: {get: isIdle},
        _dispose: {get: () => dispose}
      });
    }
  }
}
function findIndex(arr, test) {
  const index = arr.findIndex(test);
  return index < 0 ? arr.length : index;
}

const primitives = ["primitive"].concat(Object.keys(THREE).filter((key) => /^[A-Z]/.test(key)).map((key) => key[0].toLowerCase() + key.slice(1)));

const frameLoop = new FrameLoop(() => invalidate());
addEffect(() => {
  frameLoop.advance();
  return true;
});
Globals$1.assign({
  createStringInterpolator,
  colors,
  frameLoop
});
const host = createHost(primitives, {
  applyAnimatedValues: applyProps
});
const animated = host.animated;

export { animated as a, animated };
//# sourceMappingURL=index.js.map
